{
  "name": "outpipe",
  "version": "1.1.1",
  "description": "write output to a file through shell commands",
  "main": "index.js",
  "directories": {
    "example": "example"
  },
  "dependencies": {
    "shell-quote": "^1.4.2"
  },
  "devDependencies": {
    "gaze": "^0.5.1",
    "minimist": "^1.1.0",
    "osenv": "^0.1.0",
    "tape": "^3.5.0",
    "xtend": "^4.0.0"
  },
  "scripts": {
    "test": "tape test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/outpipe.git"
  },
  "keywords": [
    "output",
    "file",
    "pipe",
    "shell",
    "exec",
    "spawn",
    "createWriteStream",
    "redirect"
  ],
  "author": {
    "name": "substack"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/substack/outpipe/issues"
  },
  "homepage": "https://github.com/substack/outpipe",
  "readme": "# outpipe\n\nwrite output to a file through shell commands\n\n# purpose\n\nSuppose you have a tool like\n[watchify](https://npmjs.com/package/watchify)\nor [factor-bundle](https://npmjs.com/package/factor-bundle)\nthat write to multiple files or write to the same file more than once.\n\nIf you want to pipe the output of these tools to other programs, such as\nminification with the `uglify` command, it's very difficult! You might need to\nuse the tool's API or use a separate command to watch for changes to the output\nfiles. Ick.\n\nYou don't get the elegance of something like:\n\n``` sh\n$ browserify main.js | uglifyjs -cm | gzip > bundle.js.gz\n```\n\nUntil now! With this library and a hypothetical version of watchify, you could\ndo:\n\n``` sh\n$ watchify main.js -dv -o 'uglifyjs -cm | gzip > bundle.js.gz'\n```\n\n# example\n\nHere's a small watcher program that will just copy input files to a destination,\nbut transforms can be applied along the way with shell pipes and redirects.\n\n``` js\nvar outpipe = require('outpipe');\nvar gaze = require('gaze');\nvar fs = require('fs');\n\nvar minimist = require('minimist');\nvar argv = minimist(process.argv.slice(2), {\n    alias: { o: 'output' }\n});\n\nvar file = argv._[0];\ngaze(file, function (err, w) {\n    w.on('changed', read);\n});\nread();\n\nfunction read () {\n    var r = fs.createReadStream(file);\n    r.pipe(outpipe(argv.output));\n}\n```\n\nWe can run the program with a single output file:\n\n``` sh\n$ node watch.js input/x.js -o output/hmm.js\n```\n\nwhich just copies `x.js` to `output/hmm.js` whenever `x.js` changes.\n\nWe could also run a minification step using the `uglify` command:\n\n``` sh\n$ node watch.js input/x.js -o 'uglifyjs -cm > output/wow.js'\n```\n\nor we can just print the size of the minified and gzipped output to stdout:\n\n``` sh\n$ node watch.js input/x.js -o 'uglifyjs -cm | gzip | wc -c'\n123\n```\n\nor we could write that size to a file:\n\n``` sh\n$ node watch.js input/x.js -o 'uglifyjs -cm | gzip | wc -c > size.txt'\n```\n\n# methods\n\n``` js\nvar outpipe = require('outpipe')\n```\n\n## var w = outpipe(cmd, opts={})\n\nReturn a writable stream `w` that will pipe output to the command string `cmd`.\n\nIf `cmd` has no operators (`|` or `>`), it will write to a file.\n\nOtherwise, each command between pipes will be executed and output is written to\na file if `>` is given.\n\n`opts` can be:\n\n* `opts.env` - an object mapping environment variables to their values or a\n`function (key) {}` that returns the values.\n\nstdout and stderr are forwarded to process.stdout and process.stderr if\nunhandled in the command.\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install outpipe\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "_id": "outpipe@1.1.1",
  "dist": {
    "shasum": "43cf073856f5b2ba76ec8ef301e27745fdf47c09"
  },
  "_from": "outpipe@^1.1.0",
  "_resolved": "https://registry.npmjs.org/outpipe/-/outpipe-1.1.1.tgz"
}
